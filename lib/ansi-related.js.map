{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/ansi-related.coffee"
  ],
  "names": [],
  "mappings": "AAAA;EAAA;AAAA,MAAA;;EACA,OAAO,CAAC,KAAR,CAAc,WAAd,EAA2B,OAAA,CAAQ,QAAR,CAA3B,EADA;;;;;EAMA,UAAA,GAEE;IAAA,IAAA,EAAM,QAAA,CAAA,CAAA;aACJ,OAAO,CAAC,KAAR,CAAc,WAAd,EAA2B,OAAA,CAAQ,QAAR,CAA3B;IADI;EAAN,EARF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAyOA,MAAM,CAAC,OAAP,GAAiB;AAzOjB",
  "sourcesContent": [
    "'use strict'\nconsole.debug 'Ωbrcs___1', require './main'\n\n############################################################################################################\n#\n#===========================================================================================================\nANSI_BRICS =\n  \n  demo: ->\n    console.debug 'Ωbrcs___2', require './main'\n\n  # #===========================================================================================================\n  # ### NOTE Future Single-File Module ###\n  # require_ansi: ->\n\n  #   #=========================================================================================================\n  #   ANSI = new class Ansi\n  #     ###\n\n  #     * as for the background ('bg'), only colors and no effects can be set; in addition, the bg color can be\n  #       set to its default (or 'transparent'), which will show the terminal's or the terminal emulator's\n  #       configured bg color\n  #     * as for the foreground ('fg'), colors and effects such as blinking, bold, italic, underline, overline,\n  #       strike can be set; in addition, the configured terminal default font color can be set, and each effect\n  #       has a dedicated off-switch\n  #     * neat tables can be drawn by combining the overline effect with `│` U+2502 'Box Drawing Light Vertical\n  #       Line'; the renmarkable feature of this is that it minimizes spacing around characters meaning it's\n  #       possible to have adjacent rows of cells separated from the next row by a border without having to\n  #       sacrifice a line of text just to draw the border.\n  #     * while the two color palattes implied by the standard XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n  #       * better to only use full RGB than to fuzz around with palettes\n  #       * apps that use colors at all should be prepared for dark and bright backgrounds\n  #       * in general better to set fg, bg colors than to use reverse\n  #       * but reverse actually does do what it says—it swaps fg with bg color\n\n  #     \\x1b[39m default fg color\n  #     \\x1b[49m default bg color\n\n  #     ###\n  #     #-------------------------------------------------------------------------------------------------------\n  #     fg_from_dec: ([ r, g, b, ]) -> \"\\x1b[38:2::#{r}:#{g}:#{b}m\"\n  #     bg_from_dec: ([ r, g, b, ]) -> \"\\x1b[48:2::#{r}:#{g}:#{b}m\"\n  #     fg_from_hex: ( rhx ) -> @fg_from_dec @dec_from_hex rhx\n  #     bg_from_hex: ( rhx ) -> @bg_from_dec @dec_from_hex rhx\n  #     fg_from_name: ( name ) ->\n  #       rgb = @colors[ name ] ? @colors.fallback\n  #       return @fg_from_dec rgb\n  #     dec_from_hex: ( hex ) ->\n  #       ### TAINT use proper typing ###\n  #       throw new Error \"Ω___3 expected text, got #{rpr hex}\" unless ( typeof hex ) is 'string'\n  #       throw new Error \"Ω___4 not a proper hexadecimal RGB code: '#{hex.replace /'/g, \"\\\\'\"}'\" unless /^#[0-9a-f]{6}$/i.test hex\n  #       [ r16, g16, b16, ] = [ hex[ 1 .. 2 ], hex[ 3 .. 4 ], hex[ 5 .. 6 ], ]\n  #       return [ ( parseInt r16, 16 ), ( parseInt g16, 16 ), ( parseInt b16, 16 ), ]\n\n  #   #---------------------------------------------------------------------------------------------------------\n  #   return exports = { ANSI, }\n\n  # #===========================================================================================================\n  # ### NOTE Future Single-File Module ###\n  # require_ansi_colors_and_effects: ->\n  #   { ANSI, } = SFMODULES.require_ansi()\n  #   #.........................................................................................................\n  #   rgb_dec =\n  #     black:              [   0,   0,   0, ]\n  #     darkslategray:      [  47,  79,  79, ]\n  #     dimgray:            [ 105, 105, 105, ]\n  #     slategray:          [ 112, 128, 144, ]\n  #     gray:               [ 128, 128, 128, ]\n  #     lightslategray:     [ 119, 136, 153, ]\n  #     darkgray:           [ 169, 169, 169, ]\n  #     silver:             [ 192, 192, 192, ]\n  #     lightgray:          [ 211, 211, 211, ]\n  #     gainsboro:          [ 220, 220, 220, ]\n  #   #.........................................................................................................\n  #   rgb_hex =\n  #     white:            '#ffffff'\n  #     amethyst:         '#f0a3ff'\n  #     blue:             '#0075dc'\n  #     caramel:          '#993f00'\n  #     damson:           '#4c005c'\n  #     ebony:            '#191919'\n  #     forest:           '#005c31'\n  #     green:            '#2bce48'\n  #     lime:             '#9dcc00'\n  #     quagmire:         '#426600'\n  #     honeydew:         '#ffcc99'\n  #     iron:             '#808080'\n  #     jade:             '#94ffb5'\n  #     khaki:            '#8f7c00'\n  #     mallow:           '#c20088'\n  #     navy:             '#003380'\n  #     orpiment:         '#ffa405'\n  #     pink:             '#ffa8bb'\n  #     red:              '#ff0010'\n  #     sky:              '#5ef1f2'\n  #     turquoise:        '#00998f'\n  #     violet:           '#740aff'\n  #     wine:             '#990000'\n  #     uranium:          '#e0ff66'\n  #     xanthin:          '#ffff80'\n  #     yellow:           '#ffe100'\n  #     zinnia:           '#ff5005'\n  #   #.........................................................................................................\n  #   R =\n  #     overline1:          '\\x1b[53m'\n  #     overline0:          '\\x1b[55m'\n  #     default:            '\\x1b[39m'\n  #     bg_default:         '\\x1b[49m'\n  #     bold:               '\\x1b[1m'\n  #     bold0:              '\\x1b[22m'\n  #     italic:             '\\x1b[3m'\n  #     italic0:            '\\x1b[23m'\n  #     reset:              '\\x1b[0m'\n  #     #.......................................................................................................\n  #     black:              ANSI.fg_from_dec rgb_dec.black\n  #     darkslategray:      ANSI.fg_from_dec rgb_dec.darkslategray\n  #     dimgray:            ANSI.fg_from_dec rgb_dec.dimgray\n  #     slategray:          ANSI.fg_from_dec rgb_dec.slategray\n  #     gray:               ANSI.fg_from_dec rgb_dec.gray\n  #     lightslategray:     ANSI.fg_from_dec rgb_dec.lightslategray\n  #     darkgray:           ANSI.fg_from_dec rgb_dec.darkgray\n  #     silver:             ANSI.fg_from_dec rgb_dec.silver\n  #     lightgray:          ANSI.fg_from_dec rgb_dec.lightgray\n  #     gainsboro:          ANSI.fg_from_dec rgb_dec.gainsboro\n  #     #.......................................................................................................\n  #     white:              ANSI.fg_from_hex rgb_hex.white\n  #     amethyst:           ANSI.fg_from_hex rgb_hex.amethyst\n  #     blue:               ANSI.fg_from_hex rgb_hex.blue\n  #     caramel:            ANSI.fg_from_hex rgb_hex.caramel\n  #     damson:             ANSI.fg_from_hex rgb_hex.damson\n  #     ebony:              ANSI.fg_from_hex rgb_hex.ebony\n  #     forest:             ANSI.fg_from_hex rgb_hex.forest\n  #     green:              ANSI.fg_from_hex rgb_hex.green\n  #     lime:               ANSI.fg_from_hex rgb_hex.lime\n  #     quagmire:           ANSI.fg_from_hex rgb_hex.quagmire\n  #     honeydew:           ANSI.fg_from_hex rgb_hex.honeydew\n  #     iron:               ANSI.fg_from_hex rgb_hex.iron\n  #     jade:               ANSI.fg_from_hex rgb_hex.jade\n  #     khaki:              ANSI.fg_from_hex rgb_hex.khaki\n  #     mallow:             ANSI.fg_from_hex rgb_hex.mallow\n  #     navy:               ANSI.fg_from_hex rgb_hex.navy\n  #     orpiment:           ANSI.fg_from_hex rgb_hex.orpiment\n  #     pink:               ANSI.fg_from_hex rgb_hex.pink\n  #     red:                ANSI.fg_from_hex rgb_hex.red\n  #     sky:                ANSI.fg_from_hex rgb_hex.sky\n  #     turquoise:          ANSI.fg_from_hex rgb_hex.turquoise\n  #     violet:             ANSI.fg_from_hex rgb_hex.violet\n  #     wine:               ANSI.fg_from_hex rgb_hex.wine\n  #     uranium:            ANSI.fg_from_hex rgb_hex.uranium\n  #     xanthin:            ANSI.fg_from_hex rgb_hex.xanthin\n  #     yellow:             ANSI.fg_from_hex rgb_hex.yellow\n  #     zinnia:             ANSI.fg_from_hex rgb_hex.zinnia\n  #     #.......................................................................................................\n  #     bg_black:           ANSI.bg_from_dec rgb_dec.black\n  #     bg_darkslategray:   ANSI.bg_from_dec rgb_dec.darkslategray\n  #     bg_dimgray:         ANSI.bg_from_dec rgb_dec.dimgray\n  #     bg_slategray:       ANSI.bg_from_dec rgb_dec.slategray\n  #     bg_gray:            ANSI.bg_from_dec rgb_dec.gray\n  #     bg_lightslategray:  ANSI.bg_from_dec rgb_dec.lightslategray\n  #     bg_darkgray:        ANSI.bg_from_dec rgb_dec.darkgray\n  #     bg_silver:          ANSI.bg_from_dec rgb_dec.silver\n  #     bg_lightgray:       ANSI.bg_from_dec rgb_dec.lightgray\n  #     bg_gainsboro:       ANSI.bg_from_dec rgb_dec.gainsboro\n  #     #.......................................................................................................\n  #     bg_white:           ANSI.bg_from_hex rgb_hex.white\n  #     bg_amethyst:        ANSI.bg_from_hex rgb_hex.amethyst\n  #     bg_blue:            ANSI.bg_from_hex rgb_hex.blue\n  #     bg_caramel:         ANSI.bg_from_hex rgb_hex.caramel\n  #     bg_damson:          ANSI.bg_from_hex rgb_hex.damson\n  #     bg_ebony:           ANSI.bg_from_hex rgb_hex.ebony\n  #     bg_forest:          ANSI.bg_from_hex rgb_hex.forest\n  #     bg_green:           ANSI.bg_from_hex rgb_hex.green\n  #     bg_lime:            ANSI.bg_from_hex rgb_hex.lime\n  #     bg_quagmire:        ANSI.bg_from_hex rgb_hex.quagmire\n  #     bg_honeydew:        ANSI.bg_from_hex rgb_hex.honeydew\n  #     bg_iron:            ANSI.bg_from_hex rgb_hex.iron\n  #     bg_jade:            ANSI.bg_from_hex rgb_hex.jade\n  #     bg_khaki:           ANSI.bg_from_hex rgb_hex.khaki\n  #     bg_mallow:          ANSI.bg_from_hex rgb_hex.mallow\n  #     bg_navy:            ANSI.bg_from_hex rgb_hex.navy\n  #     bg_orpiment:        ANSI.bg_from_hex rgb_hex.orpiment\n  #     bg_pink:            ANSI.bg_from_hex rgb_hex.pink\n  #     bg_red:             ANSI.bg_from_hex rgb_hex.red\n  #     bg_sky:             ANSI.bg_from_hex rgb_hex.sky\n  #     bg_turquoise:       ANSI.bg_from_hex rgb_hex.turquoise\n  #     bg_violet:          ANSI.bg_from_hex rgb_hex.violet\n  #     bg_wine:            ANSI.bg_from_hex rgb_hex.wine\n  #     bg_uranium:         ANSI.bg_from_hex rgb_hex.uranium\n  #     bg_xanthin:         ANSI.bg_from_hex rgb_hex.xanthin\n  #     bg_yellow:          ANSI.bg_from_hex rgb_hex.yellow\n  #     bg_zinnia:          ANSI.bg_from_hex rgb_hex.zinnia\n  #   #.........................................................................................................\n  #   return { ansi_colors_and_effects: R, }\n  #       chunkify = ( text ) ->\n  #         chunks          = []\n  #         width           = 0\n  #         has_ansi        = false\n  #         chunk_has_ansi  = true\n  #         ### TAINT might as well return an empty list of chunks ###\n  #         if text is ''\n  #           return { has_ansi, width, chunks: [ { has_ansi, width, chunk: '', }, ], }\n  #         for chunk in text.split ansi_matcher\n  #           chunk_has_ansi    = not chunk_has_ansi\n  #           has_ansi        or= chunk_has_ansi\n  #           continue if chunk is ''\n  #           chunk_width       = if has_ansi then 0 else string_width chunk\n  #           width            += chunk_width\n  #           chunks.push { has_ansi: chunk_has_ansi, width: chunk_width, chunk, }\n  #         return { has_ansi, width, chunks, }\n  #         # [Symbol.iterator]: ( -> d for d in chunks )\n  #       do =>\n  #         echo '—————————————————————————————————————————————'\n  #         text = text_with_ansi_codes\n  #         urge 'Ωfstr___5',                chunkify text\n  #         info 'Ωfstr___6', d for d from ( chunkify text ).chunks\n  #       do =>\n  #         echo '—————————————————————————————————————————————'\n  #         text = 'ABCDEFXYZ'\n  #         urge 'Ωfstr___7',                chunkify text\n  #         info 'Ωfstr___8', d for d from ( chunkify text ).chunks\n  #       do =>\n  #         echo '—————————————————————————————————————————————'\n  #         text = \"#{ C.black + C.bg_red + C.bold + C.bold0 + C.default + C.bg_default }\"\n  #         urge 'Ωfstr___9',                chunkify text\n  #         info 'Ωfstr__10', d for d from ( chunkify text ).chunks\n  #       do =>\n  #         echo '—————————————————————————————————————————————'\n  #         text = ''\n  #         urge 'Ωfstr__11',                chunkify text\n  #         info 'Ωfstr__12', d for d from ( chunkify text ).chunks\n\n\n#===========================================================================================================\nmodule.exports = ANSI_BRICS\n\n"
  ]
}